<canvas id="particle-canvas" class="absolute inset-0 w-full h-full pointer-events-none z-0 mix-blend-screen"></canvas>

<script>
  class ParticleSystem {
    canvas: HTMLCanvasElement;
    ctx: CanvasRenderingContext2D;
    particles: Particle[];
    width: number;
    height: number;
    mouseX: number;
    mouseY: number;
    rotationX: number;
    rotationY: number;

    constructor() {
      this.canvas = document.getElementById('particle-canvas') as HTMLCanvasElement;
      this.ctx = this.canvas.getContext('2d')!;
      this.particles = [];
      this.width = window.innerWidth;
      this.height = window.innerHeight;
      this.mouseX = 0;
      this.mouseY = 0;
      this.rotationX = 0;
      this.rotationY = 0;

      this.init();
      this.animate();
      this.addEventListeners();
    }

    init() {
      this.resize();
      // Create particles in a sphere
      const particleCount = Math.min(window.innerWidth < 768 ? 400 : 800); 
      const radius = Math.min(this.width, this.height) * 0.35;

      for (let i = 0; i < particleCount; i++) {
        // Golden Angle distribution for even sphere coverage
        const phi = Math.acos(-1 + (2 * i) / particleCount);
        const theta = Math.sqrt(particleCount * Math.PI) * phi;

        const x = radius * Math.cos(theta) * Math.sin(phi);
        const y = radius * Math.sin(theta) * Math.sin(phi);
        const z = radius * Math.cos(phi);

        this.particles.push(new Particle(x, y, z));
      }
    }

    resize() {
      this.width = window.innerWidth;
      this.height = window.innerHeight;
      this.canvas.width = this.width;
      this.canvas.height = this.height;
      
      // Re-initialize on resize to adjust radius
      this.particles = [];
      const particleCount = Math.min(window.innerWidth < 768 ? 400 : 800);
      const radius = Math.min(this.width, this.height) * 0.35;

      for (let i = 0; i < particleCount; i++) {
        const phi = Math.acos(-1 + (2 * i) / particleCount);
        const theta = Math.sqrt(particleCount * Math.PI) * phi;

        const x = radius * Math.cos(theta) * Math.sin(phi);
        const y = radius * Math.sin(theta) * Math.sin(phi);
        const z = radius * Math.cos(phi);

        this.particles.push(new Particle(x, y, z));
      }
    }

    addEventListeners() {
      window.addEventListener('resize', () => this.resize());
      window.addEventListener('mousemove', (e) => {
        // Normalize mouse position to -1 to 1
        this.mouseX = (e.clientX / this.width) * 2 - 1;
        this.mouseY = (e.clientY / this.height) * 2 - 1;
      });
    }

    animate() {
      this.ctx.clearRect(0, 0, this.width, this.height);
      
      // Base rotation speed
      this.rotationY += 0.003;
      this.rotationX += 0.001;

      // Add mouse interaction to rotation
      const targetRotationY = this.rotationY + (this.mouseX * 0.05);
      const targetRotationX = this.rotationX + (-this.mouseY * 0.05);

      // Center of screen
      const cx = this.width * 0.75; // Shift to right side (75%)
      const cy = this.height / 2;

      // Sort particles by Z depth for correct rendering order
      this.particles.sort((a, b) => b.projectedZ - a.projectedZ);

      this.particles.forEach(particle => {
        particle.rotate(0.001 - (this.mouseY * 0.01), 0.003 + (this.mouseX * 0.01));
        particle.project(this.width, this.height, cx, cy);
        particle.draw(this.ctx);
      });

      // Draw connections between close particles
      this.drawConnections(cx, cy);

      requestAnimationFrame(() => this.animate());
    }

    drawConnections(cx: number, cy: number) {
      const maxDistance = 40; // Connection distance threshold
      
      // Only connect particles that are close in 3D space AND relatively close to front
      // Optimization: check fewer particles or use spatial partitioning if needed
      // For now, simple distance check on projected coordinates is faster but less accurate 3D
      // Let's do a hybrid: only connect if z-index is close
      
      this.ctx.lineWidth = 0.5;

      for (let i = 0; i < this.particles.length; i++) {
        const p1 = this.particles[i];
        // Skip particles that are too far back or clipped
        if (p1.z < -500 || p1.alpha <= 0) continue;

        // Check only a subset of neighbors to save performance
        for (let j = i + 1; j < Math.min(i + 15, this.particles.length); j++) {
            const p2 = this.particles[j];
            
            const dx = p1.projectedX - p2.projectedX;
            const dy = p1.projectedY - p2.projectedY;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < maxDistance) {
                const alpha = (1 - dist / maxDistance) * p1.alpha * 0.5;
                if (alpha > 0) {
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = `rgba(96, 165, 250, ${alpha})`;
                    this.ctx.moveTo(p1.projectedX, p1.projectedY);
                    this.ctx.lineTo(p2.projectedX, p2.projectedY);
                    this.ctx.stroke();
                }
            }
        }
      }
    }
  }

  class Particle {
    x: number;
    y: number;
    z: number;
    projectedX: number;
    projectedY: number;
    projectedZ: number;
    size: number;
    alpha: number;

    constructor(x: number, y: number, z: number) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.projectedX = 0;
      this.projectedY = 0;
      this.projectedZ = 0;
      this.size = 1.5;
      this.alpha = 1;
    }

    rotate(angleX: number, angleY: number) {
      // Rotate around X
      const cosX = Math.cos(angleX);
      const sinX = Math.sin(angleX);
      const y1 = this.y * cosX - this.z * sinX;
      const z1 = this.z * cosX + this.y * sinX;

      // Rotate around Y
      const cosY = Math.cos(angleY);
      const sinY = Math.sin(angleY);
      const x2 = this.x * cosY - z1 * sinY;
      const z2 = z1 * cosY + this.x * sinY;

      this.x = x2;
      this.y = y1;
      this.z = z2;
    }

    project(width: number, height: number, cx: number, cy: number) {
      const perspective = 800;
      const scale = perspective / (perspective + this.z);
      
      this.projectedX = cx + this.x * scale;
      this.projectedY = cy + this.y * scale;
      this.projectedZ = this.z; // Store for sorting
      
      // Scale size by perspective
      this.size = Math.max(0.5, 1.5 * scale);
      
      // Fade out back particles
      this.alpha = Math.min(1, Math.max(0.1, (scale - 0.5) * 2));
    }

    draw(ctx: CanvasRenderingContext2D) {
      if (this.alpha <= 0) return;
      
      ctx.beginPath();
      ctx.arc(this.projectedX, this.projectedY, this.size, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(96, 165, 250, ${this.alpha})`; // Titanium Blue
      ctx.fill();
    }
  }

  // Initialize on load and view transitions
  document.addEventListener('astro:page-load', () => {
    const canvas = document.getElementById('particle-canvas');
    if (canvas) {
        if (!(window as any).particleSystemInstance) {
             (window as any).particleSystemInstance = new ParticleSystem();
        }
    }
  });
  
  // Fallback for initial load
  if (document.readyState === 'complete') {
      const canvas = document.getElementById('particle-canvas');
      if (canvas && !(window as any).particleSystemInstance) {
          (window as any).particleSystemInstance = new ParticleSystem();
      }
  } else {
      window.addEventListener('load', () => {
          const canvas = document.getElementById('particle-canvas');
          if (canvas && !(window as any).particleSystemInstance) {
              (window as any).particleSystemInstance = new ParticleSystem();
          }
      });
  }
</script>
